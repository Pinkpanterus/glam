<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>glam</title>
</head>
<body>
	<div id="container" style="width:98%; height:98%; position:absolute;"></div>

	<script src="../../build/glam.js"></script>
	<script src="./libs/leapjs/leap-0.6.4.js"></script>
	<script src="./libs/leapjs/leap-plugins-0.1.6.js"></script>
	<script>

	var cube = null;
	var cylinder = null;
	var dirlight = null;
	var camera1 = null, camera2 = null;

	window.addEventListener('load', function(){
		var container = document.getElementById("container");
		
		var app = new glam.Viewer({ container : container, displayStats:true } );
		
		var root = new glam.Object;
		
		var dragger = new glam.PlaneDragger({ normal: new THREE.Vector3(0, 1, 1) });
		dragger.overCursor = 'pointer';
		dragger.addEventListener("mouseover", onDraggerMouseOver);
		dragger.addEventListener("mouseout", onDraggerMouseOut);
		dragger.addEventListener("mousedown", onDraggerMouseDown);
		dragger.addEventListener("mousemove", onDraggerMouseMove);
		dragger.addEventListener("mouseup", onDraggerMouseUp);
		dragger.addEventListener("mousescroll", onDraggerMouseScroll);
		dragger.addEventListener("drag", onDraggerDrag);
		
		var group = new glam.Object;
		group.addComponent(dragger);

		root.addChild(group);
		
		cube = createCube();
		group.addChild(cube);

		var obj = new glam.Object;
		obj.addComponent(new glam.AmbientLight);
		obj.light.color.setHex(0x444444);
		root.addChild(obj);

		app.addObject(root);


		app.run();

		runLeap(glam.Graphics.instance.renderer, glam.Graphics.instance.scene, glam.Graphics.instance.camera);
	},
	false
	);

	function createCube() {	
		var o = new glam.Object;

		o.transform.rotation.x = Math.PI / 6;
		
		var visual = new glam.Visual(
				{ geometry: new THREE.BoxGeometry(2, 2, 2),
					material: new THREE.MeshPhongMaterial({color:0xffaa22,
					transparent: false,
					opacity:1})
				});

		
		o.addComponent(visual);

		return o;
	}


	var savedColor = 0;
	function onDraggerMouseOver(event)
	{
		savedColor = cube.visuals[0].material.color.getHex();
		cube.visuals[0].material.color.setHex(0x00ff00);
	}
		
	function onDraggerMouseOut(event)
	{
		cube.visuals[0].material.color.setHex(savedColor);
	}

	function onDraggerMouseDown(event)
	{
//		cylinder.transform.position.copy(event.point);
	}

	function onDraggerMouseMove(event)
	{
		offset = event.point.clone();
	}
	
	function onDraggerMouseUp(event)
	{
	}

	function onDraggerMouseScroll(event)
	{
		console.log("Mouse scroll: ", event);	
	}

	function onDraggerDrag(event)
	{
		console.log("Mouse: ", event.offset);
		cube.transform.position.copy(event.offset);
	}	
	</script>

<script>
// note: before implementing based off of this, you can instead grab the boneHand plugin
// here: js.leapmotion.com


  var colors = [0xff0000, 0x00ff00, 0x0000ff];
  var baseBoneRotation = (new THREE.Quaternion).setFromEuler(
      new THREE.Euler(Math.PI / 2, 0, 0)
  );

function runLeap(renderer, scene, camera) {

	var TO_METERS = 100; // bone data in cm

  Leap.loop({background: true}, {
    hand: function (hand) {

      hand.fingers.forEach(function (finger) {

        // This is the meat of the example - Positioning `the cylinders on every frame:
        finger.data('boneMeshes').forEach(function(mesh, i){
          var bone = finger.bones[i];

          mesh.position.fromArray(bone.center());
          mesh.position.divideScalar(TO_METERS);

          mesh.setRotationFromMatrix(
            (new THREE.Matrix4).fromArray( bone.matrix() )
          );

          mesh.quaternion.multiply(baseBoneRotation);
        });

        finger.data('jointMeshes').forEach(function(mesh, i){
          var bone = finger.bones[i];

          if (bone) {
            mesh.position.fromArray(bone.prevJoint);
          }else{
            // special case for the finger tip joint sphere:
            bone = finger.bones[i-1];
            mesh.position.fromArray(bone.nextJoint);
          }

          mesh.position.divideScalar(TO_METERS);

        });

      });

      var armMesh = hand.data('armMesh');

      armMesh.position.fromArray(hand.arm.center());

      armMesh.position.divideScalar(TO_METERS);

      armMesh.setRotationFromMatrix(
        (new THREE.Matrix4).fromArray( hand.arm.matrix() )
      );

      armMesh.quaternion.multiply(baseBoneRotation);

      //armMesh.scale.x = hand.arm.width / 2;
      //armMesh.scale.z = hand.arm.width / 4;
      //armMesh.scale.divideScalar(100);

    renderer.render(scene, camera);

  }})
    // these two LeapJS plugins, handHold and handEntry are available from leapjs-plugins, included above.
    // handHold provides hand.data
    // handEntry provides handFound/handLost events.
  .use('handHold')
  .use('handEntry')
  .on('handFound', function(hand){

    hand.fingers.forEach(function (finger) {

      var boneMeshes = [];
      var jointMeshes = [];

      finger.bones.forEach(function(bone) {

        // create joints

        // CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)
        var boneMesh = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, bone.length),
            new THREE.MeshPhongMaterial({transparent:true, opacity:.1, color:0x00ffff})
        );

        boneMesh.scale.divideScalar(TO_METERS);
        boneMesh.scale.z /= 1000;

        scene.add(boneMesh);
        boneMeshes.push(boneMesh);
      });

      for (var i = 0; i < finger.bones.length + 1; i++) {

        var jointMesh = new THREE.Mesh(
            new THREE.SphereGeometry(8, 32, 32),
            new THREE.MeshPhongMaterial({transparent:true, opacity:.5, color:0x0088ce})
        );

        jointMesh.scale.divideScalar(TO_METERS);
        jointMesh.scale.y /= 1000;
        scene.add(jointMesh);
        jointMeshes.push(jointMesh);

      }


      finger.data('boneMeshes', boneMeshes);
      finger.data('jointMeshes', jointMeshes);

    });

    if (hand.arm){ // 2.0.3+ have arm api,
      // CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)
      var armMesh = new THREE.Mesh(
        new THREE.CylinderGeometry(20, 20, hand.arm.length, 64),
            new THREE.MeshPhongMaterial({transparent:true, opacity:.1, color:0x00ffff, 
            	})
      );


        armMesh.scale.divideScalar(100);
        armMesh.scale.z /= 10;
      scene.add(armMesh);

      hand.data('armMesh', armMesh);

    }

  })
  .on('handLost', function(hand){

    hand.fingers.forEach(function (finger) {

      var boneMeshes = finger.data('boneMeshes');
      var jointMeshes = finger.data('jointMeshes');

      boneMeshes.forEach(function(mesh){
        scene.remove(mesh);
      });

      jointMeshes.forEach(function(mesh){
        scene.remove(mesh);
      });

      finger.data({
        boneMeshes: null,
        boneMeshes: null
      });

    });

    var armMesh = hand.data('armMesh');
    scene.remove(armMesh);
    hand.data('armMesh', null);

    renderer.render(scene, camera);

  })
  .connect();
}

</script>

</body>
</html>